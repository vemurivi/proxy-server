using System;
using System.Collections.Generic;
using System.Reflection;

public class ClassInitializerGenerator
{
    private static readonly Random _random = new Random();

    public static object GenerateInstance(Type type)
    {
        return GenerateInstance(type, new HashSet<Type>());
    }

    private static object GenerateInstance(Type type, HashSet<Type> visitedTypes)
    {
        if (type == null)
            throw new ArgumentNullException(nameof(type));

        if (visitedTypes.Contains(type))
            return Activator.CreateInstance(type);

        visitedTypes.Add(type);

        var instance = Activator.CreateInstance(type);

        foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            var value = GetDummyValue(property.PropertyType, visitedTypes);
            property.SetValue(instance, value);
        }

        return instance;
    }

    private static object GetDummyValue(Type type, HashSet<Type> visitedTypes)
    {
        if (type.IsGenericType)
        {
            var genericTypeDefinition = type.GetGenericTypeDefinition();
            var genericArguments = type.GetGenericArguments();

            if (genericTypeDefinition == typeof(List<>))
            {
                var listType = typeof(List<>).MakeGenericType(genericArguments);
                var listInstance = Activator.CreateInstance(listType);
                return listInstance;
            }
            else if (genericTypeDefinition == typeof(Dictionary<,>))
            {
                var keyType = genericArguments[0];
                var valueType = genericArguments[1];
                var dictionaryType = typeof(Dictionary<,>).MakeGenericType(keyType, valueType);
                var dictionaryInstance = Activator.CreateInstance(dictionaryType);
                return dictionaryInstance;
            }
            else if (genericTypeDefinition == typeof(SubData<>))
            {
                var subDataType = typeof(SubData<>).MakeGenericType(genericArguments);
                var instance = Activator.CreateInstance(subDataType);

                // Recursively populate SubData properties
                foreach (var property in subDataType.GetProperties(BindingFlags.Public | BindingFlags.Instance))
                {
                    property.SetValue(instance, GetDummyValue(property.PropertyType, visitedTypes));
                }

                return instance; // Return the populated SubData instance
            }
            else if (genericTypeDefinition == typeof(Nullable<>))
            {
                var nullableType = typeof(Nullable<>).MakeGenericType(genericArguments);
                return Activator.CreateInstance(nullableType);
            }
            else
            {
                return Activator.CreateInstance(type);
            }
        }

        if (type == typeof(string)) return "dummy";
        if (type == typeof(int)) return _random.Next(1, 100); // Generate random int between 1 and 100
        if (type == typeof(double)) return _random.NextDouble() * 100; // Generate random double between 0.0 and 100.0
        if (type == typeof(bool)) return _random.Next(0, 2) == 1; // Randomly choose between true and false
        if (type == typeof(DateTime)) return DateTime.Now;
        if (type.IsEnum) return Enum.GetValues(type).GetValue(0);

        if (type.IsClass)
        {
            return GenerateInstance(type, visitedTypes);
        }

        return null;
    }

    public static void PrintObject(object obj, int level = 0)
    {
        if (obj == null)
            return;

        var indent = new string(' ', level * 2);
        var type = obj.GetType();

        Console.WriteLine($"{indent}{{");

        var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        for (int i = 0; i < properties.Length; i++)
        {
            var property = properties[i];
            var value = property.GetValue(obj);

            if (value == null)
                continue;

            Console.Write($"{indent}{property.Name} = ");

            if (value is string strValue)
            {
                Console.WriteLine($"\"{strValue}\"{(i < properties.Length - 1 ? "," : "")}");
            }
            else if (value is bool boolValue)
            {
                Console.WriteLine($"{boolValue.ToString().ToLower()}{(i < properties.Length - 1 ? "," : "")}");
            }
            else if (value.GetType().IsGenericType && value.GetType().GetGenericTypeDefinition() == typeof(SubData<>))
            {
                // Handle SubData specifically
                var subDataType = value.GetType();
                var subDataProperties = subDataType.GetProperties(BindingFlags.Public | BindingFlags.Instance);
                Console.WriteLine($"SubData<{subDataType.GetGenericArguments()[0].Name}> {{");
                foreach (var subDataProperty in subDataProperties)
                {
                    Console.WriteLine($"{indent}  {subDataProperty.Name} = {subDataProperty.GetValue(value)}");
                }
                Console.WriteLine($"{indent}}}");
            }
            else if (value.GetType().IsClass && value.GetType() != typeof(string))
            {
                Console.WriteLine();
                PrintObject(value, level + 1);
                if (i < properties.Length - 1)
                {
                    Console.WriteLine(",");
                }
            }
            else
            {
                Console.WriteLine($"{value}{(i < properties.Length - 1 ? "," : "")}");
            }
        }

        Console.WriteLine($"{indent}}}");
    }
}


public class Program
{
    public static void Main()
    {
        var instance = ClassInitializerGenerator.GenerateInstance(typeof(type));
        ClassInitializerGenerator.PrintObject(instance);
    }
}
