using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

public class ClassInitializerGenerator
{
    private static readonly Random _random = new Random();

    public static object GenerateInstance(Type type)
    {
        return GenerateInstance(type, new HashSet<Type>());
    }

    private static object GenerateInstance(Type type, HashSet<Type> visitedTypes)
    {
        if (type == null)
            throw new ArgumentNullException(nameof(type));

        if (visitedTypes.Contains(type))
            return Activator.CreateInstance(type);

        visitedTypes.Add(type);

        var instance = Activator.CreateInstance(type);

        foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            var value = GetDummyValue(property.PropertyType, visitedTypes);
            property.SetValue(instance, value);
        }

        return instance;
    }

    private static object GetDummyValue(Type type, HashSet<Type> visitedTypes)
    {
        if (type.IsGenericType)
        {
            var genericTypeDefinition = type.GetGenericTypeDefinition();
            var genericArguments = type.GetGenericArguments();

            if (genericTypeDefinition == typeof(List<>))
            {
                var listType = typeof(List<>).MakeGenericType(genericArguments);
                var listInstance = Activator.CreateInstance(listType);
                return listInstance;
            }
            else if (genericTypeDefinition == typeof(Dictionary<,>))
            {
                var keyType = genericArguments[0];
                var valueType = genericArguments[1];
                var dictionaryType = typeof(Dictionary<,>).MakeGenericType(keyType, valueType);
                var dictionaryInstance = Activator.CreateInstance(dictionaryType);
                return dictionaryInstance;
            }
            else if (genericTypeDefinition == typeof(SubData<>))
            {
                // Specifically handle SubData<>
                var subDataType = typeof(SubData<>).MakeGenericType(genericArguments);
                var instance = Activator.CreateInstance(subDataType);

                // Populate the properties with random values
                foreach (var property in subDataType.GetProperties(BindingFlags.Public | BindingFlags.Instance))
                {
                    var value = GetDummyValue(property.PropertyType, visitedTypes);
                    property.SetValue(instance, value);
                }
                return instance;
            }
            else if (genericTypeDefinition == typeof(Nullable<>))
            {
                var nullableType = typeof(Nullable<>).MakeGenericType(genericArguments);
                return Activator.CreateInstance(nullableType);
            }
            else
            {
                // Handle other generic types, including custom ones
                return Activator.CreateInstance(type);
            }
        }

        if (type == typeof(string)) return "dummy";
        if (type == typeof(int)) return _random.Next(1, 100); // Generate random int between 1 and 100
        if (type == typeof(double)) return _random.NextDouble() * 100; // Generate random double between 0.0 and 100.0
        if (type == typeof(bool)) return _random.Next(0, 2) == 1; // Randomly choose between true and false
        if (type == typeof(DateTime)) return DateTime.Now;
        if (type.IsEnum) return Enum.GetValues(type).GetValue(0);

        if (type.IsClass)
        {
            // Recursively initialize nested classes
            return GenerateInstance(type, visitedTypes);
        }

        return null;
    }

    private static string GetTypeName(Type type)
    {
        if (!type.IsGenericType)
            return type.Name;

        var genericTypeDefinition = type.GetGenericTypeDefinition();
        var genericArguments = type.GetGenericArguments();

        var sb = new StringBuilder();
        sb.Append(genericTypeDefinition.Name.Split('`')[0]); // Remove the backtick and number
        sb.Append("<");

        for (int i = 0; i < genericArguments.Length; i++)
        {
            if (i > 0)
                sb.Append(", ");

            sb.Append(GetTypeName(genericArguments[i]));
        }

        sb.Append(">");

        return sb.ToString();
    }

    private static void PrintObject(object obj, int level = 0)
    {
        if (obj == null)
            return;

        var indent = new string(' ', level * 2);
        var type = obj.GetType();
        Console.WriteLine($"{indent}{{");

        var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        for (int i = 0; i < properties.Length; i++)
        {
            var property = properties[i];
            var value = property.GetValue(obj);

            if (value == null)
                continue;

            Console.Write($"{indent}  \"{property.Name}\" = ");
            
            if (value is string strValue)
            {
                Console.WriteLine($"\"{strValue}\"{(i < properties.Length - 1 ? "," : "")}");
            }
            else if (value is bool boolValue)
            {
                Console.WriteLine($"{boolValue.ToString().ToLower()}{(i < properties.Length - 1 ? "," : "")}");
            }
            else if (value.GetType().IsClass && value.GetType() != typeof(string))
            {
                Console.WriteLine();
                PrintObject(value, level + 1);
                if (i < properties.Length - 1)
                {
                    Console.WriteLine(",");
                }
            }
            else
            {
                Console.WriteLine($"{value}{(i < properties.Length - 1 ? "," : "")}");
            }
        }

        Console.Write($"{indent}}}");
    }
}

public class Program
{
    public static void Main()
    {
        var instance = ClassInitializerGenerator.GenerateInstance(typeof(type));
        PrintObject(instance);
    }

    private static void PrintObject(object obj, int level = 0)
    {
        if (obj == null)
            return;

        var indent = new string(' ', level * 2);
        var type = obj.GetType();
        Console.WriteLine($"{indent}{{");

        var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        for (int i = 0; i < properties.Length; i++)
        {
            var property = properties[i];
            var value = property.GetValue(obj);
            if (value == null)
                continue;

            if (value is string strValue)
            {
                Console.WriteLine($"{indent}  \"{property.Name}\" = \"{strValue}\"{(i < properties.Length - 1 ? "," : "")}");
            }
            else if (value is bool boolValue)
            {
                Console.WriteLine($"{indent}  \"{property.Name}\" = {boolValue.ToString().ToLower()}{(i < properties.Length - 1 ? "," : "")}");
            }
            else if (value.GetType().IsClass && value.GetType() != typeof(string))
            {
                Console.WriteLine($"{indent}  \"{property.Name}\" = ");
                PrintObject(value, level + 1);
                if (i < properties.Length - 1)
                {
                    Console.WriteLine(",");
                }
            }
            else
            {
                Console.WriteLine($"{indent}  \"{property.Name}\" = {value}{(i < properties.Length - 1 ? "," : "")}");
            }
        }

        Console.Write($"{indent}}}");
    }
}
